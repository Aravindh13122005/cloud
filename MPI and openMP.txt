MPI:
1.sudo apt install python3
2.sudo apt install -y -qq mpich
3.sudo apd install python3-pip
4.pip install mpi4py
5.gedit mpi_example.py
6.mpirun -np 4 python3 mpi_example.py

mpi_example.py:
from mpi4py import MPI
comm=MPI.COMM_WORLD
rank=comm.GET_rank()
size=comm.GET_size()
print("Hello from the process {rank} out of {size}")


openMP:
sudo apt-get install libomp-dev

-----1)gedit hello.cpp
#include<omp.h>
#include<iostream>
int main(){
omp_set_num_threads(4){
int thread_id=omp_get_thread_num();
int threads=omp_get_num_threads();
std::cout<<"Hello world from "<<thread_id<<" out of "<<threads<<" threads.\n";
}
return 0;
}


execution:
g++ -fopenmp hello.cpp -o hello.out
./hello.out


---2)secondlargest number
#include <iostream>
#include <vector>
#include <climits>   // for INT_MIN
#include <omp.h>

int main() {
    std::vector<int> arr = {12, 45, 23, 67, 34, 89, 67, 90, 34};
    std::size_t n = arr.size();

    int globalLargest = INT_MIN;
    int globalSecond  = INT_MIN;

    #pragma omp parallel
    {
        int localLargest = INT_MIN;
        int localSecond  = INT_MIN;

        #pragma omp for nowait
        for (std::size_t i = 0; i < n; ++i) {
            int val = arr[i];
            if (val > localLargest) {
                localSecond = localLargest;
                localLargest = val;
            } else if (val > localSecond && val != localLargest) {
                localSecond = val;
            }
        }

        #pragma omp critical
        {
            if (localLargest > globalLargest) {
                // new largest found in this thread
                if (globalLargest > localSecond)
                    globalSecond = globalLargest;
                else
                    globalSecond = localSecond;
                globalLargest = localLargest;
            } else if (localLargest != globalLargest && localLargest > globalSecond) {
                globalSecond = localLargest;
            } else if (localSecond > globalSecond) {
                globalSecond = localSecond;
            }
        }
    } // end parallel

    if (globalSecond == INT_MIN) {
        std::cout << "No second largest element exists.\n";
    } else {
        std::cout << "The second largest element is: " << globalSecond << '\n';
    }

    return 0;
}

---3)simple parallel loop:
#include <iostream>
#include <omp.h>

int main() {
    // Parallel for loop using OpenMP
    #pragma omp parallel for
    for (int i = 0; i < 8; ++i) {
        int thread_id = omp_get_thread_num();
        std::cout << "Iteration " << i 
                  << " is executed by thread " << thread_id << std::endl;
    }

    return 0;
}


---4)parallel and serial sum:
#include <iostream>
#include <omp.h>
#include <chrono>

#define THREADCOUNT 5

// Serial sum function
long long serialSum(int n) {
    long long sum = 0;
    for (int i = 1; i < n; ++i)
        sum += i;
    return sum;
}

// Parallel sum function
long long parallelSum(int n) {
    long long sum = 0;
    #pragma omp parallel for reduction(+:sum)
    for (int i = 1; i < n; ++i)
        sum += i;
    return sum;
}

int main() {
    omp_set_num_threads(THREADCOUNT);
    int n = 100000000;

    // --- Serial sum timing ---
    auto start1 = std::chrono::high_resolution_clock::now();
    long long serial_result = serialSum(n);
    auto end1 = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> serial_time = end1 - start1;

    // --- Parallel sum timing ---
    auto start2 = std::chrono::high_resolution_clock::now();
    long long parallel_result = parallelSum(n);
    auto end2 = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> parallel_time = end2 - start2;

    // --- Output results ---
    std::cout << "Serial sum:   " << serial_result 
              << " in " << serial_time.count() << " seconds.\n";
    std::cout << "Parallel sum: " << parallel_result 
              << " in " << parallel_time.count() << " seconds.\n";

    return 0;
}



